PragmaDirective
   Source: "pragma solidity ^0.5.0;"
ImportDirective "./IERC20.sol"
   Source: "import \"./IERC20.sol\";"
ImportDirective "./SafeMath.sol"
   Source: "import \"./SafeMath.sol\";"
ContractDefinition "ERC20"
   Source: "contract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}"
  InheritanceSpecifier
     Source: "IERC20"
    UserDefinedTypeName "IERC20"
       Source: "IERC20"
  UsingForDirective
     Source: "using SafeMath for uint256;"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "_balances"
     Type: mapping(address => uint256)
     Source: "mapping (address => uint256) private _balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "_allowances"
     Type: mapping(address => mapping(address => uint256))
     Source: "mapping (address => mapping (address => uint256)) private _allowances"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "_totalSupply"
     Type: uint256
     Source: "uint256 private _totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "totalSupply" - public - const
     Source: "function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n        return _totalSupply;\n    }"
      Return
         Source: "return _totalSupply"
        Identifier _totalSupply
           Type: uint256
           Source: "_totalSupply"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }"
    ParameterList
       Source: "(address account)"
      VariableDeclaration "account"
         Type: address
         Source: "address account"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n        return _balances[account];\n    }"
      Return
         Source: "return _balances[account]"
        IndexAccess
           Type: uint256
           Source: "_balances[account]"
          Identifier _balances
             Type: mapping(address => uint256)
             Source: "_balances"
          Identifier account
             Type: address
             Source: "account"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }"
    ParameterList
       Source: "(address recipient, uint256 amount)"
      VariableDeclaration "recipient"
         Type: address
         Source: "address recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }"
      ExpressionStatement
         Source: "_transfer(msg.sender, recipient, amount)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(msg.sender, recipient, amount)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier recipient
             Type: address
             Source: "recipient"
          Identifier amount
             Type: uint256
             Source: "amount"
      Return
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n        return _allowances[owner][spender];\n    }"
      Return
         Source: "return _allowances[owner][spender]"
        IndexAccess
           Type: uint256
           Source: "_allowances[owner][spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "_allowances[owner]"
            Identifier _allowances
               Type: mapping(address => mapping(address => uint256))
               Source: "_allowances"
            Identifier owner
               Type: address
               Source: "owner"
          Identifier spender
             Type: address
             Source: "spender"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }"
    ParameterList
       Source: "(address spender, uint256 value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        _approve(msg.sender, spender, value);\n        return true;\n    }"
      ExpressionStatement
         Source: "_approve(msg.sender, spender, value)"
        FunctionCall
           Type: tuple()
           Source: "_approve(msg.sender, spender, value)"
          Identifier _approve
             Type: function (address,address,uint256)
             Source: "_approve"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier spender
             Type: address
             Source: "spender"
          Identifier value
             Type: uint256
             Source: "value"
      Return
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }"
    ParameterList
       Source: "(address sender, address recipient, uint256 amount)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "recipient"
         Type: address
         Source: "address recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }"
      ExpressionStatement
         Source: "_transfer(sender, recipient, amount)"
        FunctionCall
           Type: tuple()
           Source: "_transfer(sender, recipient, amount)"
          Identifier _transfer
             Type: function (address,address,uint256)
             Source: "_transfer"
          Identifier sender
             Type: address
             Source: "sender"
          Identifier recipient
             Type: address
             Source: "recipient"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Source: "_approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount))"
        FunctionCall
           Type: tuple()
           Source: "_approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount))"
          Identifier _approve
             Type: function (address,address,uint256)
             Source: "_approve"
          Identifier sender
             Type: address
             Source: "sender"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: uint256
             Source: "_allowances[sender][msg.sender].sub(amount)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_allowances[sender][msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "_allowances[sender][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "_allowances[sender]"
                  Identifier _allowances
                     Type: mapping(address => mapping(address => uint256))
                     Source: "_allowances"
                  Identifier sender
                     Type: address
                     Source: "sender"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier amount
               Type: uint256
               Source: "amount"
      Return
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "increaseAllowance" - public
     Source: "function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }"
    ParameterList
       Source: "(address spender, uint256 addedValue)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "addedValue"
         Type: uint256
         Source: "uint256 addedValue"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }"
      ExpressionStatement
         Source: "_approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue))"
        FunctionCall
           Type: tuple()
           Source: "_approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue))"
          Identifier _approve
             Type: function (address,address,uint256)
             Source: "_approve"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier spender
             Type: address
             Source: "spender"
          FunctionCall
             Type: uint256
             Source: "_allowances[msg.sender][spender].add(addedValue)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_allowances[msg.sender][spender].add"
              IndexAccess
                 Type: uint256
                 Source: "_allowances[msg.sender][spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "_allowances[msg.sender]"
                  Identifier _allowances
                     Type: mapping(address => mapping(address => uint256))
                     Source: "_allowances"
                  MemberAccess to member sender
                     Type: address payable
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier spender
                   Type: address
                   Source: "spender"
            Identifier addedValue
               Type: uint256
               Source: "addedValue"
      Return
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "decreaseAllowance" - public
     Source: "function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }"
    ParameterList
       Source: "(address spender, uint256 subtractedValue)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "subtractedValue"
         Type: uint256
         Source: "uint256 subtractedValue"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }"
      ExpressionStatement
         Source: "_approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue))"
        FunctionCall
           Type: tuple()
           Source: "_approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue))"
          Identifier _approve
             Type: function (address,address,uint256)
             Source: "_approve"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier spender
             Type: address
             Source: "spender"
          FunctionCall
             Type: uint256
             Source: "_allowances[msg.sender][spender].sub(subtractedValue)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_allowances[msg.sender][spender].sub"
              IndexAccess
                 Type: uint256
                 Source: "_allowances[msg.sender][spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "_allowances[msg.sender]"
                  Identifier _allowances
                     Type: mapping(address => mapping(address => uint256))
                     Source: "_allowances"
                  MemberAccess to member sender
                     Type: address payable
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier spender
                   Type: address
                   Source: "spender"
            Identifier subtractedValue
               Type: uint256
               Source: "subtractedValue"
      Return
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "_transfer"
     Source: "function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }"
    ParameterList
       Source: "(address sender, address recipient, uint256 amount)"
      VariableDeclaration "sender"
         Type: address
         Source: "address sender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "recipient"
         Type: address
         Source: "address recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }"
      ExpressionStatement
         Source: "require(sender != address(0), \"ERC20: transfer from the zero address\")"
        FunctionCall
           Type: tuple()
           Source: "require(sender != address(0), \"ERC20: transfer from the zero address\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "sender != address(0)"
            Identifier sender
               Type: address
               Source: "sender"
            FunctionCall
               Type: address payable
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: ERC20: transfer from the zero address
             Type: literal_string "ERC20: transfer from the zero address"
             Source: "\"ERC20: transfer from the zero address\""
      ExpressionStatement
         Source: "require(recipient != address(0), \"ERC20: transfer to the zero address\")"
        FunctionCall
           Type: tuple()
           Source: "require(recipient != address(0), \"ERC20: transfer to the zero address\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "recipient != address(0)"
            Identifier recipient
               Type: address
               Source: "recipient"
            FunctionCall
               Type: address payable
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: ERC20: transfer to the zero address
             Type: literal_string "ERC20: transfer to the zero address"
             Source: "\"ERC20: transfer to the zero address\""
      ExpressionStatement
         Source: "_balances[sender] = _balances[sender].sub(amount)"
        Assignment using operator =
           Type: uint256
           Source: "_balances[sender] = _balances[sender].sub(amount)"
          IndexAccess
             Type: uint256
             Source: "_balances[sender]"
            Identifier _balances
               Type: mapping(address => uint256)
               Source: "_balances"
            Identifier sender
               Type: address
               Source: "sender"
          FunctionCall
             Type: uint256
             Source: "_balances[sender].sub(amount)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_balances[sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "_balances[sender]"
                Identifier _balances
                   Type: mapping(address => uint256)
                   Source: "_balances"
                Identifier sender
                   Type: address
                   Source: "sender"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Source: "_balances[recipient] = _balances[recipient].add(amount)"
        Assignment using operator =
           Type: uint256
           Source: "_balances[recipient] = _balances[recipient].add(amount)"
          IndexAccess
             Type: uint256
             Source: "_balances[recipient]"
            Identifier _balances
               Type: mapping(address => uint256)
               Source: "_balances"
            Identifier recipient
               Type: address
               Source: "recipient"
          FunctionCall
             Type: uint256
             Source: "_balances[recipient].add(amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_balances[recipient].add"
              IndexAccess
                 Type: uint256
                 Source: "_balances[recipient]"
                Identifier _balances
                   Type: mapping(address => uint256)
                   Source: "_balances"
                Identifier recipient
                   Type: address
                   Source: "recipient"
            Identifier amount
               Type: uint256
               Source: "amount"
      EmitStatement
         Source: "emit Transfer(sender, recipient, amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(sender, recipient, amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier sender
             Type: address
             Source: "sender"
          Identifier recipient
             Type: address
             Source: "recipient"
          Identifier amount
             Type: uint256
             Source: "amount"
  FunctionDefinition "_mint"
     Source: "function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }"
    ParameterList
       Source: "(address account, uint256 amount)"
      VariableDeclaration "account"
         Type: address
         Source: "address account"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }"
      ExpressionStatement
         Source: "require(account != address(0), \"ERC20: mint to the zero address\")"
        FunctionCall
           Type: tuple()
           Source: "require(account != address(0), \"ERC20: mint to the zero address\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "account != address(0)"
            Identifier account
               Type: address
               Source: "account"
            FunctionCall
               Type: address payable
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: ERC20: mint to the zero address
             Type: literal_string "ERC20: mint to the zero address"
             Source: "\"ERC20: mint to the zero address\""
      ExpressionStatement
         Source: "_totalSupply = _totalSupply.add(amount)"
        Assignment using operator =
           Type: uint256
           Source: "_totalSupply = _totalSupply.add(amount)"
          Identifier _totalSupply
             Type: uint256
             Source: "_totalSupply"
          FunctionCall
             Type: uint256
             Source: "_totalSupply.add(amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_totalSupply.add"
              Identifier _totalSupply
                 Type: uint256
                 Source: "_totalSupply"
            Identifier amount
               Type: uint256
               Source: "amount"
      ExpressionStatement
         Source: "_balances[account] = _balances[account].add(amount)"
        Assignment using operator =
           Type: uint256
           Source: "_balances[account] = _balances[account].add(amount)"
          IndexAccess
             Type: uint256
             Source: "_balances[account]"
            Identifier _balances
               Type: mapping(address => uint256)
               Source: "_balances"
            Identifier account
               Type: address
               Source: "account"
          FunctionCall
             Type: uint256
             Source: "_balances[account].add(amount)"
            MemberAccess to member add
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_balances[account].add"
              IndexAccess
                 Type: uint256
                 Source: "_balances[account]"
                Identifier _balances
                   Type: mapping(address => uint256)
                   Source: "_balances"
                Identifier account
                   Type: address
                   Source: "account"
            Identifier amount
               Type: uint256
               Source: "amount"
      EmitStatement
         Source: "emit Transfer(address(0), account, amount)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(address(0), account, amount)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          FunctionCall
             Type: address payable
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier account
             Type: address
             Source: "account"
          Identifier amount
             Type: uint256
             Source: "amount"
  FunctionDefinition "_burn"
     Source: "function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }"
    ParameterList
       Source: "(address account, uint256 value)"
      VariableDeclaration "account"
         Type: address
         Source: "address account"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }"
      ExpressionStatement
         Source: "require(account != address(0), \"ERC20: burn from the zero address\")"
        FunctionCall
           Type: tuple()
           Source: "require(account != address(0), \"ERC20: burn from the zero address\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "account != address(0)"
            Identifier account
               Type: address
               Source: "account"
            FunctionCall
               Type: address payable
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: ERC20: burn from the zero address
             Type: literal_string "ERC20: burn from the zero address"
             Source: "\"ERC20: burn from the zero address\""
      ExpressionStatement
         Source: "_totalSupply = _totalSupply.sub(value)"
        Assignment using operator =
           Type: uint256
           Source: "_totalSupply = _totalSupply.sub(value)"
          Identifier _totalSupply
             Type: uint256
             Source: "_totalSupply"
          FunctionCall
             Type: uint256
             Source: "_totalSupply.sub(value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_totalSupply.sub"
              Identifier _totalSupply
                 Type: uint256
                 Source: "_totalSupply"
            Identifier value
               Type: uint256
               Source: "value"
      ExpressionStatement
         Source: "_balances[account] = _balances[account].sub(value)"
        Assignment using operator =
           Type: uint256
           Source: "_balances[account] = _balances[account].sub(value)"
          IndexAccess
             Type: uint256
             Source: "_balances[account]"
            Identifier _balances
               Type: mapping(address => uint256)
               Source: "_balances"
            Identifier account
               Type: address
               Source: "account"
          FunctionCall
             Type: uint256
             Source: "_balances[account].sub(value)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_balances[account].sub"
              IndexAccess
                 Type: uint256
                 Source: "_balances[account]"
                Identifier _balances
                   Type: mapping(address => uint256)
                   Source: "_balances"
                Identifier account
                   Type: address
                   Source: "account"
            Identifier value
               Type: uint256
               Source: "value"
      EmitStatement
         Source: "emit Transfer(account, address(0), value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(account, address(0), value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier account
             Type: address
             Source: "account"
          FunctionCall
             Type: address payable
             Source: "address(0)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier value
             Type: uint256
             Source: "value"
  FunctionDefinition "_approve"
     Source: "function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }"
    ParameterList
       Source: "(address owner, address spender, uint256 value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }"
      ExpressionStatement
         Source: "require(owner != address(0), \"ERC20: approve from the zero address\")"
        FunctionCall
           Type: tuple()
           Source: "require(owner != address(0), \"ERC20: approve from the zero address\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "owner != address(0)"
            Identifier owner
               Type: address
               Source: "owner"
            FunctionCall
               Type: address payable
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: ERC20: approve from the zero address
             Type: literal_string "ERC20: approve from the zero address"
             Source: "\"ERC20: approve from the zero address\""
      ExpressionStatement
         Source: "require(spender != address(0), \"ERC20: approve to the zero address\")"
        FunctionCall
           Type: tuple()
           Source: "require(spender != address(0), \"ERC20: approve to the zero address\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "spender != address(0)"
            Identifier spender
               Type: address
               Source: "spender"
            FunctionCall
               Type: address payable
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: ERC20: approve to the zero address
             Type: literal_string "ERC20: approve to the zero address"
             Source: "\"ERC20: approve to the zero address\""
      ExpressionStatement
         Source: "_allowances[owner][spender] = value"
        Assignment using operator =
           Type: uint256
           Source: "_allowances[owner][spender] = value"
          IndexAccess
             Type: uint256
             Source: "_allowances[owner][spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "_allowances[owner]"
              Identifier _allowances
                 Type: mapping(address => mapping(address => uint256))
                 Source: "_allowances"
              Identifier owner
                 Type: address
                 Source: "owner"
            Identifier spender
               Type: address
               Source: "spender"
          Identifier value
             Type: uint256
             Source: "value"
      EmitStatement
         Source: "emit Approval(owner, spender, value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(owner, spender, value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          Identifier owner
             Type: address
             Source: "owner"
          Identifier spender
             Type: address
             Source: "spender"
          Identifier value
             Type: uint256
             Source: "value"
  FunctionDefinition "_burnFrom"
     Source: "function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }"
    ParameterList
       Source: "(address account, uint256 amount)"
      VariableDeclaration "account"
         Type: address
         Source: "address account"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint256 amount"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
    Block
       Source: "{\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }"
      ExpressionStatement
         Source: "_burn(account, amount)"
        FunctionCall
           Type: tuple()
           Source: "_burn(account, amount)"
          Identifier _burn
             Type: function (address,uint256)
             Source: "_burn"
          Identifier account
             Type: address
             Source: "account"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Source: "_approve(account, msg.sender, _allowances[account][msg.sender].sub(amount))"
        FunctionCall
           Type: tuple()
           Source: "_approve(account, msg.sender, _allowances[account][msg.sender].sub(amount))"
          Identifier _approve
             Type: function (address,address,uint256)
             Source: "_approve"
          Identifier account
             Type: address
             Source: "account"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          FunctionCall
             Type: uint256
             Source: "_allowances[account][msg.sender].sub(amount)"
            MemberAccess to member sub
               Type: function (uint256,uint256) pure returns (uint256)
               Source: "_allowances[account][msg.sender].sub"
              IndexAccess
                 Type: uint256
                 Source: "_allowances[account][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "_allowances[account]"
                  Identifier _allowances
                     Type: mapping(address => mapping(address => uint256))
                     Source: "_allowances"
                  Identifier account
                     Type: address
                     Source: "account"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
            Identifier amount
               Type: uint256
               Source: "amount"
